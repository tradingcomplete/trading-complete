// ===========================================
// å®Œå…¨ã‚¯ãƒªã‚¢ï¼‹50ä»¶ãƒ‡ãƒ¼ã‚¿ä½œæˆï¼ˆç¢ºå®Ÿç‰ˆï¼‰
// ===========================================

console.log('=== ãƒ‡ãƒ¼ã‚¿å®Œå…¨å‰Šé™¤ï¼‹æ–°è¦ä½œæˆ ===\n');

// ã‚¹ãƒ†ãƒƒãƒ—1: æ—¢å­˜ãƒ‡ãƒ¼ã‚¿ã‚’å®Œå…¨å‰Šé™¤
console.log('ã€ã‚¹ãƒ†ãƒƒãƒ—1: æ—¢å­˜ãƒ‡ãƒ¼ã‚¿å‰Šé™¤ã€‘');
localStorage.removeItem('trades');
localStorage.removeItem('yenProfitLoss');
console.log('âœ… æ—¢å­˜ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤ã—ã¾ã—ãŸ\n');

// ç¢ºèª
const checkEmpty = localStorage.getItem('trades');
console.log('å‰Šé™¤ç¢ºèª:', checkEmpty === null ? 'âœ… å®Œå…¨ã«å‰Šé™¤ã•ã‚Œã¾ã—ãŸ' : 'âš ï¸ ã¾ã ãƒ‡ãƒ¼ã‚¿ãŒæ®‹ã£ã¦ã„ã¾ã™');
console.log('');

// ã‚¹ãƒ†ãƒƒãƒ—2: æ–°ã—ã„50ä»¶ãƒ‡ãƒ¼ã‚¿ä½œæˆ
console.log('ã€ã‚¹ãƒ†ãƒƒãƒ—2: æ–°ãƒ‡ãƒ¼ã‚¿ä½œæˆé–‹å§‹ã€‘\n');

// ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
function randomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

function randomFloat(min, max, decimals = 2) {
    return parseFloat((Math.random() * (max - min) + min).toFixed(decimals));
}

function randomChoice(array) {
    return array[Math.floor(Math.random() * array.length)];
}

function generateId(date, index) {
    const timestamp = new Date(date).getTime();
    return `trade_${timestamp}_${index}_${randomInt(100000, 999999)}`;
}

// ãƒã‚¹ã‚¿ãƒ¼ãƒ‡ãƒ¼ã‚¿
const pairs = [
    { pair: 'USD/JPY', pipValue: 1000, priceDecimals: 3 },
    { pair: 'EUR/USD', pipValue: 1000, priceDecimals: 5 },
    { pair: 'GBP/JPY', pipValue: 1000, priceDecimals: 3 },
    { pair: 'EUR/JPY', pipValue: 1000, priceDecimals: 3 },
    { pair: 'AUD/USD', pipValue: 1000, priceDecimals: 5 }
];

const directions = ['long', 'short'];

const reasons = [
    ['ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«åˆ†æ', 'ã‚µãƒãƒ¼ãƒˆãƒ©ã‚¤ãƒ³åç™º', ''],
    ['ãƒˆãƒ¬ãƒ³ãƒ‰ãƒ•ã‚©ãƒ­ãƒ¼', 'ç§»å‹•å¹³å‡ç·šã‚¯ãƒ­ã‚¹', ''],
    ['ãƒ•ã‚¡ãƒ³ãƒ€ãƒ¡ãƒ³ã‚¿ãƒ«ã‚º', 'çµŒæ¸ˆæŒ‡æ¨™ç™ºè¡¨', ''],
    ['ãƒãƒ£ãƒ¼ãƒˆãƒ‘ã‚¿ãƒ¼ãƒ³', 'ãƒ€ãƒ–ãƒ«ãƒœãƒˆãƒ ç¢ºèª', ''],
    ['ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«åˆ†æ', 'RSIéç†±æ„Ÿ', '']
];

const reflections = [
    'æƒ³å®šé€šã‚Šã®å±•é–‹ã€‚ã‚¨ãƒ³ãƒˆãƒªãƒ¼ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã‚‚è‰¯å¥½ã€‚',
    'æåˆ‡ã‚Šåˆ¤æ–­ãŒæ—©ã™ããŸã€‚ã‚‚ã†å°‘ã—å¾…ã¤ã¹ãã ã£ãŸã€‚',
    'åˆ©ç¢ºä½ç½®ãŒè¿‘ã™ããŸã€‚å¤§ããªãƒˆãƒ¬ãƒ³ãƒ‰ã‚’é€ƒã—ãŸã€‚',
    'ã‚¨ãƒ³ãƒˆãƒªãƒ¼æ ¹æ‹ ã¯æ­£ã—ã‹ã£ãŸãŒã€ãƒã‚¸ã‚·ãƒ§ãƒ³ã‚µã‚¤ã‚ºãŒå¤§ãã™ããŸã€‚',
    'äºˆæƒ³å¤–ã®çµŒæ¸ˆæŒ‡æ¨™ã§æ€¥å¤‰å‹•ã€‚ã‚¹ãƒˆãƒƒãƒ—ã«å¼•ã£ã‹ã‹ã£ãŸã€‚',
    'å®Œç’§ãªãƒˆãƒ¬ãƒ¼ãƒ‰ã€‚è¨ˆç”»é€šã‚Šã«å®Ÿè¡Œã§ããŸã€‚',
    'ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆãŒæ‚ªã‹ã£ãŸã€‚ã‚‚ã†å°‘ã—å¼•ãã¤ã‘ã‚‹ã¹ãã€‚',
    'å«ã¿ç›Šã‚’æŠ±ãˆã™ãã¦æ¬²ãŒå‡ºãŸã€‚æ—©ã‚ã«åˆ©ç¢ºã™ã¹ãã ã£ãŸã€‚',
    'ãƒˆãƒ¬ãƒ³ãƒ‰è»¢æ›ã®ã‚µã‚¤ãƒ³ã‚’è¦‹é€ƒã—ãŸã€‚æå¤±ã‚’æŠ‘ãˆã‚‰ã‚ŒãŸã€‚',
    'é€±æœ«æŒã¡è¶Šã—ã®ãƒªã‚¹ã‚¯ã‚’è€ƒæ…®ã›ãšå¤±æ•—ã€‚',
    'ã‚µãƒãƒ¼ãƒˆãƒ©ã‚¤ãƒ³åç™ºã‚’æ­£ç¢ºã«æ‰ãˆã‚‰ã‚ŒãŸã€‚',
    'ç›¸å ´ã®å‹¢ã„ã«ä¹—ã‚ŒãŸã€‚R:Ræ¯”ã‚‚è‰¯å¥½ã€‚',
    'é€†æŒ‡å€¤ã®ä½ç½®ãŒè¿‘ã™ããŸã€‚ã‚‚ã†å°‘ã—ä½™è£•ã‚’æŒã¤ã¹ãã€‚',
    'ãƒ•ã‚¡ãƒ³ãƒ€ãƒ¡ãƒ³ã‚¿ãƒ«ã‚ºã‚’è»½è¦–ã—ãŸçµæœã®æå¤±ã€‚',
    'åˆ©ç›Šç¢ºå®šãƒ«ãƒ¼ãƒ«ã‚’å®ˆã‚Œã¦æº€è¶³ã€‚',
    'ãƒ¬ãƒ³ã‚¸ç›¸å ´ã§ã®ãƒˆãƒ¬ãƒ¼ãƒ‰ã¯é¿ã‘ã‚‹ã¹ãã ã£ãŸã€‚',
    'ãƒ–ãƒ¬ã‚¤ã‚¯ã‚¢ã‚¦ãƒˆå¾Œã®æŠ¼ã—ç›®ã§ä¸Šæ‰‹ãå…¥ã‚ŒãŸã€‚',
    'æ„Ÿæƒ…çš„ã«ãªã£ã¦è¿½åŠ ã‚¨ãƒ³ãƒˆãƒªãƒ¼ã€‚å¤±æ•—ã€‚',
    'ãƒœãƒ©ãƒ†ã‚£ãƒªãƒ†ã‚£ãŒé«˜ã™ããŸã€‚ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚‚åºƒãŒã£ãŸã€‚',
    'æˆ‘æ…¢å¼·ãå¾…ã£ãŸãŠã‹ã’ã§è‰¯ã„ãƒã‚¤ãƒ³ãƒˆã§å…¥ã‚ŒãŸã€‚'
];

// æœˆåˆ¥ãƒ‡ãƒ¼ã‚¿é…åˆ†
const monthlyDistribution = [
    { month: '2025-01', count: 3 },
    { month: '2025-02', count: 4 },
    { month: '2025-03', count: 5 },
    { month: '2025-04', count: 6 },
    { month: '2025-05', count: 5 },
    { month: '2025-06', count: 6 },
    { month: '2025-07', count: 5 },
    { month: '2025-08', count: 5 },
    { month: '2025-09', count: 5 },
    { month: '2025-10', count: 6 }
];

// å‹æ•—ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆ58%å‹ç‡ï¼‰
const winPattern = [
    1, 1, 0, 1, 1,  // 1-5
    1, 0, 1, 1, 0,  // 6-10
    1, 1, 1, 0, 0,  // 11-15
    1, 0, 1, 1, 1,  // 16-20
    0, 1, 1, 0, 1,  // 21-25
    1, 1, 0, 1, 0,  // 26-30
    1, 1, 1, 0, 1,  // 31-35
    0, 1, 1, 1, 0,  // 36-40
    1, 0, 1, 1, 1,  // 41-45
    0, 1, 1, 0, 1   // 46-50
]; // 29å‹21æ•— = 58%

// ãƒˆãƒ¬ãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆ
const freshTrades = [];
let tradeIndex = 0;

monthlyDistribution.forEach(({ month, count }) => {
    for (let i = 0; i < count; i++) {
        const day = randomInt(1, 28);
        const entryHour = randomInt(0, 23);
        const entryMinute = randomInt(0, 59);
        
        const entryDate = `${month}-${String(day).padStart(2, '0')}`;
        const entryTime = `${entryDate}T${String(entryHour).padStart(2, '0')}:${String(entryMinute).padStart(2, '0')}`;
        
        // æ±ºæ¸ˆã¯1-5æ—¥å¾Œ
        const exitDay = Math.min(day + randomInt(1, 5), 28);
        const exitHour = randomInt(0, 23);
        const exitMinute = randomInt(0, 59);
        const exitDate = `${month}-${String(exitDay).padStart(2, '0')}T${String(exitHour).padStart(2, '0')}:${String(exitMinute).padStart(2, '0')}`;
        
        // é€šè²¨ãƒšã‚¢é¸æŠ
        const pairData = randomChoice(pairs);
        const direction = randomChoice(directions);
        const lot = randomChoice([0.1, 0.2, 0.5, 1.0, 1.5, 2.0]);
        
        // ä¾¡æ ¼ç”Ÿæˆ
        let basePrice;
        if (pairData.pair.includes('JPY')) {
            basePrice = randomFloat(130, 160, pairData.priceDecimals);
        } else {
            basePrice = randomFloat(1.0, 1.3, pairData.priceDecimals);
        }
        
        const entryPrice = basePrice;
        
        // å‹æ•—åˆ¤å®š
        const isWin = winPattern[tradeIndex] === 1;
        
        let pips, exitPrice, stopLoss, takeProfit;
        
        if (isWin) {
            // å‹ã¡ãƒˆãƒ¬ãƒ¼ãƒ‰: 10-50 pips
            pips = randomInt(10, 50);
            if (direction === 'long') {
                exitPrice = parseFloat((entryPrice + (pips * (pairData.priceDecimals === 5 ? 0.00001 : 0.001))).toFixed(pairData.priceDecimals));
                stopLoss = parseFloat((entryPrice - (pips * 0.6 * (pairData.priceDecimals === 5 ? 0.00001 : 0.001))).toFixed(pairData.priceDecimals));
                takeProfit = exitPrice;
            } else {
                exitPrice = parseFloat((entryPrice - (pips * (pairData.priceDecimals === 5 ? 0.00001 : 0.001))).toFixed(pairData.priceDecimals));
                stopLoss = parseFloat((entryPrice + (pips * 0.6 * (pairData.priceDecimals === 5 ? 0.00001 : 0.001))).toFixed(pairData.priceDecimals));
                takeProfit = exitPrice;
            }
        } else {
            // è² ã‘ãƒˆãƒ¬ãƒ¼ãƒ‰: -10 to -35 pips
            pips = -randomInt(10, 35);
            if (direction === 'long') {
                exitPrice = parseFloat((entryPrice + (pips * (pairData.priceDecimals === 5 ? 0.00001 : 0.001))).toFixed(pairData.priceDecimals));
                stopLoss = exitPrice;
                takeProfit = parseFloat((entryPrice + (Math.abs(pips) * 1.5 * (pairData.priceDecimals === 5 ? 0.00001 : 0.001))).toFixed(pairData.priceDecimals));
            } else {
                exitPrice = parseFloat((entryPrice - (pips * (pairData.priceDecimals === 5 ? 0.00001 : 0.001))).toFixed(pairData.priceDecimals));
                stopLoss = exitPrice;
                takeProfit = parseFloat((entryPrice - (Math.abs(pips) * 1.5 * (pairData.priceDecimals === 5 ? 0.00001 : 0.001))).toFixed(pairData.priceDecimals));
            }
        }
        
        // å††å»ºã¦æç›Šè¨ˆç®—
        const profitLoss = pips * lot * pairData.pipValue;
        const swap = randomInt(-300, 100);
        const commission = -Math.floor(lot * 50);
        const netProfit = profitLoss + swap + commission;
        
        // ãƒˆãƒ¬ãƒ¼ãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆä½œæˆ
        const trade = {
            id: generateId(entryDate, tradeIndex),
            date: entryDate,
            pair: pairData.pair,
            symbol: pairData.pair,
            direction: direction,
            entryPrice: entryPrice,
            exitPrice: exitPrice,
            stopLoss: stopLoss,
            takeProfit: takeProfit,
            lotSize: lot,
            lot: lot,
            yenProfitLoss: {
                profitLoss: profitLoss,
                swap: swap,
                commission: commission,
                netProfit: netProfit
            },
            profitLoss: profitLoss,
            swap: swap,
            commission: commission,
            netProfitLoss: netProfit,
            exits: [
                {
                    time: exitDate,
                    price: exitPrice,
                    lot: lot,
                    pips: pips
                }
            ],
            chartImages: [],
            reasons: randomChoice(reasons),
            scenario: `${pairData.pair}ã®${direction === 'long' ? 'ä¸Šæ˜‡' : 'ä¸‹é™'}ãƒˆãƒ¬ãƒ³ãƒ‰ã‚’ç‹™ã†`,
            entryEmotion: '',
            reflection: randomChoice(reflections),
            entryMethod: 'manual',
            isBulkEntry: false,
            status: 'closed',
            createdAt: `${entryTime}:00.000Z`,
            updatedAt: `${exitDate}:00.000Z`,
            entryTime: entryTime,
            entryDatetime: entryTime,
            lots: lot,
            pips: pips,
            exitDate: exitDate,
            tradePL: null,
            swapPoints: null,
            timestamp: entryTime
        };
        
        freshTrades.push(trade);
        tradeIndex++;
    }
});

console.log(`âœ… ${freshTrades.length}ä»¶ã®ãƒˆãƒ¬ãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿ã‚’ç”Ÿæˆã—ã¾ã—ãŸ\n`);

// çµ±è¨ˆæƒ…å ±è¡¨ç¤º
const wins = freshTrades.filter(t => t.pips > 0).length;
const losses = freshTrades.length - wins;
const totalPips = freshTrades.reduce((sum, t) => sum + t.pips, 0);
const totalProfit = freshTrades.reduce((sum, t) => sum + t.netProfitLoss, 0);

console.log('ã€çµ±è¨ˆæƒ…å ±ã€‘');
console.log(`ç·ãƒˆãƒ¬ãƒ¼ãƒ‰æ•°: ${freshTrades.length}ä»¶`);
console.log(`å‹ã¡ãƒˆãƒ¬ãƒ¼ãƒ‰: ${wins}ä»¶`);
console.log(`è² ã‘ãƒˆãƒ¬ãƒ¼ãƒ‰: ${losses}ä»¶`);
console.log(`å‹ç‡: ${(wins / freshTrades.length * 100).toFixed(1)}%`);
console.log(`ç·ç²å¾—Pips: ${totalPips.toFixed(1)} pips`);
console.log(`ç·æç›Š: Â¥${totalProfit.toLocaleString()}`);

// æœˆåˆ¥åˆ†å¸ƒç¢ºèª
console.log('\nã€æœˆåˆ¥åˆ†å¸ƒã€‘');
const monthCount = {};
freshTrades.forEach(trade => {
    const month = trade.date.substring(0, 7);
    monthCount[month] = (monthCount[month] || 0) + 1;
});
Object.keys(monthCount).sort().forEach(month => {
    console.log(`${month}: ${monthCount[month]}ä»¶`);
});

// ã‚¹ãƒ†ãƒƒãƒ—3: localStorageã«ä¿å­˜
console.log('\nã€ã‚¹ãƒ†ãƒƒãƒ—3: æ–°ãƒ‡ãƒ¼ã‚¿ä¿å­˜ã€‘');
localStorage.setItem('trades', JSON.stringify(freshTrades));
console.log('âœ… æ–°ãƒ‡ãƒ¼ã‚¿ï¼ˆ50ä»¶ï¼‰ã‚’ä¿å­˜ã—ã¾ã—ãŸ');

// æœ€çµ‚ç¢ºèª
const finalCheck = JSON.parse(localStorage.getItem('trades') || '[]');
console.log(`\nã€æœ€çµ‚ç¢ºèªã€‘`);
console.log(`ä¿å­˜ã•ã‚ŒãŸãƒˆãƒ¬ãƒ¼ãƒ‰æ•°: ${finalCheck.length}ä»¶`);
console.log(finalCheck.length === 50 ? 'âœ… å®Œç’§ï¼50ä»¶ã§ã™' : `âš ï¸ ${finalCheck.length}ä»¶ã«ãªã£ã¦ã„ã¾ã™`);

console.log('\n=== ãƒ‡ãƒ¼ã‚¿ä½œæˆå®Œäº† ===');
console.log('ğŸ”„ å¿…ãšãƒšãƒ¼ã‚¸ã‚’ãƒªãƒ­ãƒ¼ãƒ‰ï¼ˆF5ï¼‰ã—ã¦ãã ã•ã„ï¼');